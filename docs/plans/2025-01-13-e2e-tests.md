# End-to-End Testing Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement comprehensive end-to-end tests that validate complete user workflows from UI interaction through file/IPC operations.

**Architecture:** Headless GTK testing using Broadway backend with GLib.MainContext event loop management. Tests launch real application instances, simulate user interactions, and verify state changes in both UI and filesystem.

**Tech Stack:** pytest, GTK4, Adw (Libadwaita), GLib.MainContext, Broadway backend

---

## Task 1: Application Lifecycle Manager

**Files:**
- Create: `tests/e2e/__init__.py`
- Create: `tests/e2e/app_lifecycle.py`

**Step 1: Write failing test**

Create `tests/e2e/test_app_lifecycle.py`:

```python
"""Test application lifecycle manager."""
import pytest
from tests.e2e.app_lifecycle import setup_headless_display, ApplicationContext


def test_setup_headless_display():
    """Test headless display configuration."""
    setup_headless_display()

    import os
    assert 'GDK_BACKEND' in os.environ
    assert os.environ['GDK_BACKEND'] == 'broadway'


def test_application_context_manager():
    """Test application context manager lifecycle."""
    from pathlib import Path
    import tempfile

    with tempfile.NamedTemporaryFile(mode='w', suffix='.conf', delete=False) as f:
        f.write("# Test config\n")
        config_path = Path(f.name)

    try:
        with ApplicationContext(config_path) as (app, window):
            assert app is not None
            assert window is not None
            assert window.config_manager.config_path == config_path
    finally:
        config_path.unlink()
```

**Step 2: Run test to verify it fails**

```bash
cd /home/komi/repos/hyprbind/worktrees/e2e
.venv/bin/pytest tests/e2e/test_app_lifecycle.py -v
```

Expected: FAIL with "No module named 'tests.e2e.app_lifecycle'"

**Step 3: Write minimal implementation**

Create `tests/e2e/__init__.py`:

```python
"""End-to-end tests for HyprBind application."""
```

Create `tests/e2e/app_lifecycle.py`:

```python
"""Application lifecycle management for E2E tests."""
import os
import gi

gi.require_version("Gtk", "4.0")
gi.require_version("Adw", "1")

from gi.repository import Gtk, Adw, GLib
from pathlib import Path
from typing import Tuple
from contextlib import contextmanager


def setup_headless_display() -> None:
    """Configure GTK for headless operation using Broadway backend.

    Broadway is GTK4's HTML5 backend that doesn't require a display server.
    This allows tests to run without X11 or Wayland.
    """
    os.environ['GDK_BACKEND'] = 'broadway'
    os.environ['BROADWAY_DISPLAY'] = ':5'

    # Suppress GTK warnings in headless mode
    os.environ['G_MESSAGES_DEBUG'] = ''


def launch_app(config_path: Path) -> Tuple[Adw.Application, 'MainWindow']:
    """Launch application without blocking event loop.

    Args:
        config_path: Path to Hyprland config file for testing

    Returns:
        Tuple of (application, main_window)
    """
    from hyprbind.ui.main_window import MainWindow

    # Create application
    app = Adw.Application(application_id="dev.hyprbind.e2e.test")

    # Create main window with test config
    window = MainWindow(application=app)
    window.config_manager.config_path = config_path

    return app, window


def shutdown_app(app: Adw.Application) -> None:
    """Gracefully shutdown application and cleanup GTK resources.

    Args:
        app: Application instance to shutdown
    """
    # Close all windows
    for window in app.get_windows():
        window.close()

    # Process remaining events
    context = GLib.MainContext.default()
    while context.pending():
        context.iteration(False)

    # Quit application
    app.quit()


@contextmanager
def ApplicationContext(config_path: Path):
    """Context manager for application lifecycle.

    Ensures proper cleanup even if test fails.

    Args:
        config_path: Path to test config file

    Yields:
        Tuple of (application, main_window)
    """
    setup_headless_display()
    app, window = launch_app(config_path)

    try:
        yield app, window
    finally:
        shutdown_app(app)
```

**Step 4: Run test to verify it passes**

```bash
.venv/bin/pytest tests/e2e/test_app_lifecycle.py -v
```

Expected: PASS (2 tests)

**Step 5: Commit**

```bash
git add tests/e2e/ docs/plans/2025-01-13-e2e-tests.md
git commit -m "feat: Add E2E application lifecycle manager

- Headless display setup with Broadway backend
- Application launch/shutdown utilities
- Context manager for test isolation
- Graceful GTK resource cleanup

ðŸ¤– Generated with Claude Code
https://claude.com/claude-code

Co-Authored-By: Claude <noreply@anthropic.com>"
```

---

## Task 2: GTK Event Loop Utilities

**Files:**
- Create: `tests/e2e/gtk_utils.py`

**Step 1: Write failing test**

Create `tests/e2e/test_gtk_utils.py`:

```python
"""Test GTK event loop utilities."""
import pytest
import gi
import time

gi.require_version("Gtk", "4.0")
from gi.repository import Gtk, GLib

from tests.e2e.gtk_utils import (
    wait_for_condition,
    process_pending_events,
    find_widget_by_name,
    simulate_click,
    simulate_text_entry,
)


def test_wait_for_condition_success():
    """Test wait_for_condition succeeds when predicate becomes true."""
    flag = {'value': False}

    def set_flag():
        flag['value'] = True
        return GLib.SOURCE_REMOVE

    GLib.timeout_add(100, set_flag)  # Set flag after 100ms

    result = wait_for_condition(lambda: flag['value'], timeout=1.0)
    assert result is True


def test_wait_for_condition_timeout():
    """Test wait_for_condition raises on timeout."""
    with pytest.raises(TimeoutError):
        wait_for_condition(lambda: False, timeout=0.1)


def test_process_pending_events():
    """Test processing pending GTK events."""
    process_pending_events()  # Should not hang


def test_find_widget_by_name():
    """Test finding widget by name in hierarchy."""
    box = Gtk.Box()
    box.set_name("test_box")

    button = Gtk.Button()
    button.set_name("test_button")
    box.append(button)

    found = find_widget_by_name(box, "test_button")
    assert found == button

    not_found = find_widget_by_name(box, "nonexistent")
    assert not_found is None


def test_simulate_click():
    """Test simulating button click."""
    clicked = {'value': False}

    button = Gtk.Button()
    button.connect("clicked", lambda b: clicked.update({'value': True}))

    simulate_click(button)
    assert clicked['value'] is True


def test_simulate_text_entry():
    """Test simulating text entry."""
    entry = Gtk.Entry()

    simulate_text_entry(entry, "test text")
    assert entry.get_text() == "test text"
```

**Step 2: Run test to verify it fails**

```bash
.venv/bin/pytest tests/e2e/test_gtk_utils.py -v
```

Expected: FAIL with "No module named 'tests.e2e.gtk_utils'"

**Step 3: Write minimal implementation**

Create `tests/e2e/gtk_utils.py`:

```python
"""GTK event loop and widget utilities for E2E tests."""
import time
import gi

gi.require_version("Gtk", "4.0")
gi.require_version("Adw", "1")

from gi.repository import Gtk, Adw, GLib
from typing import Callable, Optional


def wait_for_condition(
    predicate: Callable[[], bool],
    timeout: float = 5.0,
    poll_interval: float = 0.01
) -> bool:
    """Wait for condition while processing GTK events.

    Args:
        predicate: Function that returns True when condition is met
        timeout: Maximum time to wait in seconds
        poll_interval: Time between condition checks in seconds

    Returns:
        True if condition met within timeout

    Raises:
        TimeoutError: If condition not met within timeout
    """
    start = time.time()
    context = GLib.MainContext.default()

    while time.time() - start < timeout:
        if predicate():
            return True

        # Process pending GTK events
        while context.pending():
            context.iteration(False)

        time.sleep(poll_interval)

    raise TimeoutError(f"Condition not met within {timeout}s")


def process_pending_events(max_iterations: int = 100) -> None:
    """Drain GTK event queue.

    Args:
        max_iterations: Maximum number of events to process
    """
    context = GLib.MainContext.default()
    iterations = 0

    while context.pending() and iterations < max_iterations:
        context.iteration(False)
        iterations += 1


def find_widget_by_name(container: Gtk.Widget, name: str) -> Optional[Gtk.Widget]:
    """Recursively find widget by name in widget hierarchy.

    Args:
        container: Container widget to search
        name: Widget name to find

    Returns:
        Widget if found, None otherwise
    """
    if container.get_name() == name:
        return container

    # Check children
    child = container.get_first_child()
    while child:
        result = find_widget_by_name(child, name)
        if result:
            return result
        child = child.get_next_sibling()

    return None


def simulate_click(widget: Gtk.Widget) -> None:
    """Programmatically activate widget.

    Args:
        widget: Widget to activate (Button, Switch, etc.)
    """
    if isinstance(widget, Gtk.Button):
        widget.emit("clicked")
    elif isinstance(widget, Gtk.Switch):
        widget.set_active(not widget.get_active())
    elif isinstance(widget, Gtk.CheckButton):
        widget.set_active(not widget.get_active())

    # Process resulting events
    process_pending_events()


def simulate_text_entry(entry: Gtk.Entry, text: str) -> None:
    """Type text into entry field.

    Args:
        entry: Entry widget
        text: Text to enter
    """
    entry.set_text(text)
    process_pending_events()
```

**Step 4: Run test to verify it passes**

```bash
.venv/bin/pytest tests/e2e/test_gtk_utils.py -v
```

Expected: PASS (6 tests)

**Step 5: Commit**

```bash
git add tests/e2e/gtk_utils.py tests/e2e/test_gtk_utils.py
git commit -m "feat: Add GTK event loop utilities for E2E tests

- wait_for_condition: Poll with event processing
- process_pending_events: Drain event queue
- find_widget_by_name: Recursive widget search
- simulate_click: Programmatic widget activation
- simulate_text_entry: Form field input

All utilities tested with GTK widget interactions.

ðŸ¤– Generated with Claude Code
https://claude.com/claude-code

Co-Authored-By: Claude <noreply@anthropic.com>"
```

---

## Task 3: E2E Test Fixtures

**Files:**
- Create: `tests/e2e/conftest.py`

**Step 1: Write failing test**

Create `tests/e2e/test_fixtures.py`:

```python
"""Test E2E fixtures."""
import pytest
from pathlib import Path


def test_headless_display_fixture(headless_display):
    """Test headless display setup fixture."""
    import os
    assert os.environ['GDK_BACKEND'] == 'broadway'


def test_temp_config_file_fixture(temp_config_file):
    """Test temporary config file fixture."""
    assert temp_config_file.exists()
    content = temp_config_file.read_text()
    assert "bindd" in content


def test_e2e_app_fixture(e2e_app):
    """Test E2E app fixture provides application and window."""
    app, window = e2e_app
    assert app is not None
    assert window is not None
    assert window.config_manager.config_path is not None
```

**Step 2: Run test to verify it fails**

```bash
.venv/bin/pytest tests/e2e/test_fixtures.py -v
```

Expected: FAIL with "fixture 'headless_display' not found"

**Step 3: Write minimal implementation**

Create `tests/e2e/conftest.py`:

```python
"""Pytest fixtures for E2E tests."""
import pytest
import tempfile
from pathlib import Path

from tests.e2e.app_lifecycle import setup_headless_display, ApplicationContext


@pytest.fixture(scope="session")
def headless_display():
    """Setup headless display for all E2E tests (once per session)."""
    setup_headless_display()
    yield


@pytest.fixture
def temp_config_file(tmp_path):
    """Create temporary Hyprland config file for testing.

    Args:
        tmp_path: Pytest temp directory

    Returns:
        Path to temporary config file
    """
    config_file = tmp_path / "test_keybinds.conf"
    config_file.write_text("""# Test Configuration

$mainMod = SUPER

# Window Management
bindd = $mainMod, Q, Close window, killactive,
bindd = $mainMod SHIFT, Q, Force close, exec, hyprctl kill

# Applications
bindd = $mainMod, RETURN, Terminal, exec, alacritty
bindd = $mainMod, E, File manager, exec, nemo

# Testing
bindd = $mainMod, T, Test binding, exec, test-command
""")

    return config_file


@pytest.fixture
def e2e_app(headless_display, temp_config_file):
    """Create application instance for E2E testing.

    Yields:
        Tuple of (application, main_window)
    """
    with ApplicationContext(temp_config_file) as (app, window):
        yield app, window
```

**Step 4: Run test to verify it passes**

```bash
.venv/bin/pytest tests/e2e/test_fixtures.py -v
```

Expected: PASS (3 tests)

**Step 5: Commit**

```bash
git add tests/e2e/conftest.py tests/e2e/test_fixtures.py
git commit -m "feat: Add E2E test fixtures

- headless_display: Session-wide display setup
- temp_config_file: Temporary test configs
- e2e_app: Fresh app instance per test

Provides isolated test environment with automatic cleanup.

ðŸ¤– Generated with Claude Code
https://claude.com/claude-code

Co-Authored-By: Claude <noreply@anthropic.com>"
```

---

## Task 4: Add Binding Workflow Test

**Files:**
- Create: `tests/e2e/test_add_binding.py`

**Step 1: Write failing test**

Create `tests/e2e/test_add_binding.py`:

```python
"""Test add binding end-to-end workflow."""
import pytest
from tests.e2e.gtk_utils import (
    wait_for_condition,
    find_widget_by_name,
    simulate_click,
    simulate_text_entry,
    process_pending_events,
)


def test_add_binding_end_to_end(e2e_app, temp_config_file):
    """Test complete add binding workflow: UI â†’ file.

    Steps:
    1. Launch app with test config (5 bindings)
    2. Click Add button
    3. Fill binding form
    4. Click Save
    5. Verify binding in UI list
    6. Verify binding in config file
    """
    app, window = e2e_app

    # Wait for config to load
    wait_for_condition(
        lambda: window.config_manager.config is not None,
        timeout=2.0
    )

    # Get editor tab
    editor_tab = window.editor_tab
    initial_count = editor_tab.list_store.get_n_items()

    # Click Add button
    simulate_click(editor_tab.add_button)
    process_pending_events()

    # Wait for dialog to appear
    # Find BindingDialog - it should be transient for main window
    dialog = None
    for win in app.get_windows():
        if win != window and hasattr(win, 'key_entry'):
            dialog = win
            break

    assert dialog is not None, "Binding dialog should appear"

    # Fill form
    simulate_text_entry(dialog.key_entry, "W")
    simulate_text_entry(dialog.modifiers_entry, "$mainMod")
    simulate_text_entry(dialog.description_entry, "New test binding")
    simulate_text_entry(dialog.action_entry, "exec")
    simulate_text_entry(dialog.params_entry, "test-app")

    # Click Save
    save_button = None
    header = dialog.get_first_child()  # HeaderBar
    if header:
        child = header.get_first_child()
        while child:
            if isinstance(child, Gtk.Button) and child.get_label() == "Save":
                save_button = child
                break
            child = child.get_next_sibling()

    assert save_button is not None, "Save button should exist"
    simulate_click(save_button)

    # Wait for dialog to close and UI to update
    wait_for_condition(
        lambda: editor_tab.list_store.get_n_items() > initial_count,
        timeout=2.0
    )

    # Verify binding in UI
    assert editor_tab.list_store.get_n_items() == initial_count + 1

    # Verify binding in config file
    config_content = temp_config_file.read_text()
    assert "bindd = $mainMod, W, New test binding, exec, test-app" in config_content
```

**Step 2: Run test to verify it fails**

```bash
.venv/bin/pytest tests/e2e/test_add_binding.py -v
```

Expected: FAIL (test exists but implementation may have bugs)

**Step 3: Fix any issues found in test run**

Add missing import at top of file:

```python
import gi
gi.require_version("Gtk", "4.0")
from gi.repository import Gtk
```

**Step 4: Run test to verify it passes**

```bash
.venv/bin/pytest tests/e2e/test_add_binding.py -v
```

Expected: PASS

**Step 5: Commit**

```bash
git add tests/e2e/test_add_binding.py
git commit -m "feat: Add binding creation E2E test

Tests complete workflow:
- Click Add button â†’ Dialog appears
- Fill form fields â†’ Validation
- Click Save â†’ Dialog closes
- Verify UI updated â†’ List shows new binding
- Verify file updated â†’ Config contains binding

Validates end-to-end integration from UI to filesystem.

ðŸ¤– Generated with Claude Code
https://claude.com/claude-code

Co-Authored-By: Claude <noreply@anthropic.com>"
```

---

## Task 5: Edit Binding Workflow Test

**Files:**
- Create: `tests/e2e/test_edit_binding.py`

**Step 1: Write failing test**

Create `tests/e2e/test_edit_binding.py`:

```python
"""Test edit binding end-to-end workflow."""
import pytest
import gi

gi.require_version("Gtk", "4.0")
from gi.repository import Gtk

from tests.e2e.gtk_utils import (
    wait_for_condition,
    simulate_click,
    simulate_text_entry,
    process_pending_events,
)


def test_edit_binding_end_to_end(e2e_app, temp_config_file):
    """Test complete edit binding workflow: UI â†’ file update.

    Steps:
    1. Launch app with test config
    2. Select existing binding
    3. Click Edit button
    4. Modify binding (change key Q â†’ W)
    5. Click Save
    6. Verify UI shows updated binding
    7. Verify config file updated
    """
    app, window = e2e_app

    # Wait for config to load
    wait_for_condition(
        lambda: window.config_manager.config is not None,
        timeout=2.0
    )

    editor_tab = window.editor_tab

    # Select first non-header item (first actual binding)
    selection_model = editor_tab.selection_model
    # Find first non-header
    for i in range(selection_model.get_n_items()):
        item = selection_model.get_item(i)
        if not item.is_header:
            selection_model.select_item(i, True)
            break

    process_pending_events()

    # Get original binding for verification
    selected_item = selection_model.get_selected_item()
    original_key = selected_item.binding.key

    # Click Edit button
    simulate_click(editor_tab.edit_button)
    process_pending_events()

    # Wait for dialog
    dialog = None
    for win in app.get_windows():
        if win != window and hasattr(win, 'key_entry'):
            dialog = win
            break

    assert dialog is not None, "Edit dialog should appear"

    # Verify form populated with existing values
    assert dialog.key_entry.get_text() == original_key

    # Change key to "W"
    simulate_text_entry(dialog.key_entry, "W")

    # Click Save
    save_button = None
    header = dialog.get_first_child()
    if header:
        child = header.get_first_child()
        while child:
            if isinstance(child, Gtk.Button) and child.get_label() == "Save":
                save_button = child
                break
            child = child.get_next_sibling()

    simulate_click(save_button)

    # Wait for update
    wait_for_condition(
        lambda: not any(
            win for win in app.get_windows()
            if win != window and hasattr(win, 'key_entry')
        ),
        timeout=2.0
    )

    # Verify config file updated
    config_content = temp_config_file.read_text()
    assert ", W," in config_content  # New key
    # Original key should still exist for other bindings or be replaced
```

**Step 2: Run test to verify it fails**

```bash
.venv/bin/pytest tests/e2e/test_edit_binding.py -v
```

Expected: FAIL initially, then PASS after fixes

**Step 3-4: Fix and verify**

Make any necessary adjustments based on test output.

**Step 5: Commit**

```bash
git add tests/e2e/test_edit_binding.py
git commit -m "feat: Add binding edit E2E test

Tests complete edit workflow:
- Select existing binding â†’ Form pre-populated
- Modify fields â†’ Validation
- Save changes â†’ Dialog closes
- Verify UI updated â†’ Shows new values
- Verify file updated â†’ Old removed, new added

ðŸ¤– Generated with Claude Code
https://claude.com/claude-code

Co-Authored-By: Claude <noreply@anthropic.com>"
```

---

## Task 6: Delete Binding Workflow Test

**Files:**
- Create: `tests/e2e/test_delete_binding.py`

**Step 1: Write test**

Create `tests/e2e/test_delete_binding.py`:

```python
"""Test delete binding end-to-end workflow."""
import pytest
import gi

gi.require_version("Gtk", "4.0")
gi.require_version("Adw", "1")
from gi.repository import Gtk, Adw

from tests.e2e.gtk_utils import (
    wait_for_condition,
    simulate_click,
    process_pending_events,
)


def test_delete_binding_with_confirmation(e2e_app, temp_config_file):
    """Test complete delete binding workflow with confirmation.

    Steps:
    1. Launch app
    2. Select binding
    3. Click Delete
    4. Verify confirmation dialog
    5. Click Delete in dialog
    6. Verify binding removed from UI
    7. Verify binding removed from file
    """
    app, window = e2e_app

    # Wait for config
    wait_for_condition(
        lambda: window.config_manager.config is not None,
        timeout=2.0
    )

    editor_tab = window.editor_tab
    initial_count = editor_tab.list_store.get_n_items()

    # Select first binding
    selection_model = editor_tab.selection_model
    for i in range(selection_model.get_n_items()):
        item = selection_model.get_item(i)
        if not item.is_header:
            selection_model.select_item(i, True)
            binding_to_delete = item.binding
            break

    # Click Delete
    simulate_click(editor_tab.delete_button)
    process_pending_events()

    # Find confirmation dialog (Adw.MessageDialog)
    confirm_dialog = None
    for win in app.get_windows():
        if win != window and isinstance(win, Adw.MessageDialog):
            confirm_dialog = win
            break

    assert confirm_dialog is not None, "Confirmation dialog should appear"

    # Click Delete response (response="delete")
    confirm_dialog.emit("response", "delete")
    process_pending_events()

    # Wait for deletion to process
    wait_for_condition(
        lambda: editor_tab.list_store.get_n_items() < initial_count,
        timeout=2.0
    )

    # Verify removed from UI
    assert editor_tab.list_store.get_n_items() == initial_count - 1

    # Verify removed from file
    config_content = temp_config_file.read_text()
    # The deleted binding should not be in config
    assert binding_to_delete.description not in config_content
```

**Step 2-5: Run, fix, verify, commit**

```bash
.venv/bin/pytest tests/e2e/test_delete_binding.py -v

git add tests/e2e/test_delete_binding.py
git commit -m "feat: Add binding delete E2E test

Tests complete delete workflow:
- Select binding â†’ Delete button enabled
- Click Delete â†’ Confirmation appears
- Confirm deletion â†’ Dialog closes
- Verify UI updated â†’ Binding removed
- Verify file updated â†’ Binding line removed

ðŸ¤– Generated with Claude Code
https://claude.com/claude-code

Co-Authored-By: Claude <noreply@anthropic.com>"
```

---

## Task 7: Mode Switching Workflow Test

**Files:**
- Create: `tests/e2e/test_mode_switching.py`

**Step 1: Write test**

Create `tests/e2e/test_mode_switching.py`:

```python
"""Test Safe/Live mode switching workflow."""
import pytest
from unittest.mock import patch, MagicMock
import gi

gi.require_version("Gtk", "4.0")
gi.require_version("Adw", "1")
from gi.repository import Gtk, Adw

from tests.e2e.gtk_utils import (
    wait_for_condition,
    simulate_click,
    process_pending_events,
)
from hyprbind.core.mode_manager import Mode


@patch("hyprbind.ipc.hyprland_client.HyprlandClient.is_running")
def test_safe_to_live_mode_switch(mock_is_running, e2e_app):
    """Test switching from Safe to Live mode.

    Steps:
    1. Start in Safe mode (default)
    2. Mock Hyprland as running
    3. Toggle mode switch
    4. Confirm in dialog
    5. Verify mode label shows "Live"
    6. Verify banner appears
    """
    mock_is_running.return_value = True

    app, window = e2e_app

    # Verify starts in Safe mode
    assert window.mode_manager.get_mode() == Mode.SAFE
    assert window.mode_label.get_text() == "Safe"

    # Toggle mode switch
    simulate_click(window.mode_switch)
    process_pending_events()

    # Find confirmation dialog
    confirm_dialog = None
    for win in app.get_windows():
        if win != window and isinstance(win, Adw.MessageDialog):
            confirm_dialog = win
            break

    assert confirm_dialog is not None, "Mode confirmation should appear"

    # Click Enable
    confirm_dialog.emit("response", "enable")
    process_pending_events()

    # Verify mode changed
    assert window.mode_manager.get_mode() == Mode.LIVE
    assert window.mode_label.get_text() == "Live"
    assert window.live_mode_banner.get_revealed()


@patch("hyprbind.ipc.hyprland_client.HyprlandClient.is_running")
def test_live_to_safe_mode_switch(mock_is_running, e2e_app):
    """Test switching from Live to Safe mode.

    Steps:
    1. Start in Live mode
    2. Toggle switch off
    3. Verify mode label shows "Safe"
    4. Verify banner hidden
    """
    mock_is_running.return_value = True

    app, window = e2e_app

    # Switch to Live first
    window.mode_manager.set_mode(Mode.LIVE)
    window._update_mode_ui()

    assert window.mode_manager.get_mode() == Mode.LIVE

    # Toggle back to Safe
    simulate_click(window.mode_switch)
    process_pending_events()

    # Verify switched to Safe
    assert window.mode_manager.get_mode() == Mode.SAFE
    assert window.mode_label.get_text() == "Safe"
    assert not window.live_mode_banner.get_revealed()
```

**Step 2-5: Run, fix, verify, commit**

```bash
.venv/bin/pytest tests/e2e/test_mode_switching.py -v

git add tests/e2e/test_mode_switching.py
git commit -m "feat: Add mode switching E2E tests

Tests Safe â†” Live mode workflows:
- Toggle to Live â†’ Confirmation â†’ Mode changes
- Live mode UI â†’ Banner revealed, label updated
- Toggle to Safe â†’ Immediate switch
- Safe mode UI â†’ Banner hidden, label updated

Validates complete mode switching integration.

ðŸ¤– Generated with Claude Code
https://claude.com/claude-code

Co-Authored-By: Claude <noreply@anthropic.com>"
```

---

## Task 8: Config Lifecycle Test

**Files:**
- Create: `tests/e2e/test_config_lifecycle.py`

**Step 1: Write test**

Create `tests/e2e/test_config_lifecycle.py`:

```python
"""Test config load/save lifecycle."""
import pytest
from tests.e2e.gtk_utils import wait_for_condition


def test_load_and_save_config(e2e_app, temp_config_file):
    """Test complete config lifecycle: load â†’ modify â†’ save.

    Steps:
    1. Create config with 5 bindings
    2. Launch app
    3. Wait for async load
    4. Verify all bindings loaded
    5. Modify config via ConfigManager
    6. Save to file
    7. Reload from file
    8. Verify modification persisted
    """
    app, window = e2e_app

    # Wait for async load to complete
    wait_for_condition(
        lambda: window.config_manager.config is not None,
        timeout=2.0
    )

    # Verify all bindings loaded
    all_bindings = window.config_manager.config.get_all_bindings()
    assert len(all_bindings) == 5, "Should load 5 test bindings"

    # Modify first binding
    first_binding = all_bindings[0]
    from hyprbind.core.models import Binding, BindType

    modified_binding = Binding(
        type=first_binding.type,
        modifiers=first_binding.modifiers,
        key="Z",  # Changed from Q
        description=first_binding.description,
        action=first_binding.action,
        params=first_binding.params,
        submap=first_binding.submap,
        line_number=first_binding.line_number,
        category=first_binding.category,
    )

    # Remove old, add modified
    window.config_manager.remove_binding(first_binding)
    window.config_manager.add_binding(modified_binding)

    # Save to file
    result = window.config_manager.save()
    assert result.success, "Save should succeed"

    # Reload from file
    window.config_manager.load()

    # Verify modification persisted
    reloaded_bindings = window.config_manager.config.get_all_bindings()
    keys = [b.key for b in reloaded_bindings]
    assert "Z" in keys, "Modified key should persist"
```

**Step 2-5: Run, fix, verify, commit**

```bash
.venv/bin/pytest tests/e2e/test_config_lifecycle.py -v

git add tests/e2e/test_config_lifecycle.py
git commit -m "feat: Add config lifecycle E2E test

Tests complete config workflow:
- Async load â†’ All bindings loaded
- Modify via ConfigManager â†’ State updated
- Save to file â†’ Atomic write
- Reload â†’ Modifications persist

Validates end-to-end config persistence.

ðŸ¤– Generated with Claude Code
https://claude.com/claude-code

Co-Authored-By: Claude <noreply@anthropic.com>"
```

---

## Task 9: Run Full E2E Suite and Verify

**Step 1: Run all E2E tests**

```bash
cd /home/komi/repos/hyprbind/worktrees/e2e
.venv/bin/pytest tests/e2e/ -v --tb=short
```

Expected output:
```
tests/e2e/test_add_binding.py::test_add_binding_end_to_end PASSED
tests/e2e/test_app_lifecycle.py::test_setup_headless_display PASSED
tests/e2e/test_app_lifecycle.py::test_application_context_manager PASSED
tests/e2e/test_config_lifecycle.py::test_load_and_save_config PASSED
tests/e2e/test_delete_binding.py::test_delete_binding_with_confirmation PASSED
tests/e2e/test_edit_binding.py::test_edit_binding_end_to_end PASSED
tests/e2e/test_fixtures.py::test_headless_display_fixture PASSED
tests/e2e/test_fixtures.py::test_temp_config_file_fixture PASSED
tests/e2e/test_fixtures.py::test_e2e_app_fixture PASSED
tests/e2e/test_gtk_utils.py::test_wait_for_condition_success PASSED
tests/e2e/test_gtk_utils.py::test_wait_for_condition_timeout PASSED
tests/e2e/test_gtk_utils.py::test_process_pending_events PASSED
tests/e2e/test_gtk_utils.py::test_find_widget_by_name PASSED
tests/e2e/test_gtk_utils.py::test_simulate_click PASSED
tests/e2e/test_gtk_utils.py::test_simulate_text_entry PASSED
tests/e2e/test_mode_switching.py::test_safe_to_live_mode_switch PASSED
tests/e2e/test_mode_switching.py::test_live_to_safe_mode_switch PASSED

================ 17 passed in X.XXs ================
```

**Step 2: Run full test suite including E2E**

```bash
.venv/bin/pytest tests/ -v | tail -20
```

Verify E2E tests integrate cleanly with existing 322 tests.

**Step 3: Generate coverage report**

```bash
.venv/bin/pytest tests/e2e/ --cov=src/hyprbind --cov-report=term-missing
```

**Step 4: Update documentation**

Add to `README.md` (if exists) or create `tests/e2e/README.md`:

```markdown
# End-to-End Tests

Comprehensive E2E tests that validate complete user workflows from UI interaction to file/IPC operations.

## Running E2E Tests

```bash
# Run only E2E tests
pytest tests/e2e/ -v

# Run all tests including E2E
pytest tests/ -v

# Run with coverage
pytest tests/e2e/ --cov=src/hyprbind
```

## Test Coverage

- **Add Binding**: UI interaction â†’ file write
- **Edit Binding**: Selection â†’ modification â†’ persistence
- **Delete Binding**: Confirmation â†’ removal from UI and file
- **Mode Switching**: Safe â†” Live toggle with UI updates
- **Config Lifecycle**: Load â†’ modify â†’ save â†’ reload

## Architecture

- **Headless Testing**: Broadway backend (no display required)
- **Event Loop**: GLib.MainContext for async handling
- **Fixtures**: Isolated app instances per test
- **Utilities**: Widget finding, event simulation, condition waiting
```

**Step 5: Commit documentation and final verification**

```bash
git add tests/e2e/README.md README.md
git commit -m "docs: Add E2E testing documentation

- Test coverage overview
- Running instructions
- Architecture notes

ðŸ¤– Generated with Claude Code
https://claude.com/claude-code

Co-Authored-By: Claude <noreply@anthropic.com>"
```

---

## Verification Checklist

After completing all tasks, verify:

- [ ] All 17 E2E tests pass
- [ ] E2E tests integrate with existing 322 tests (no regressions)
- [ ] Tests run in < 30 seconds
- [ ] Headless mode works (no display required)
- [ ] Clean test output (no GTK warnings/errors)
- [ ] Coverage includes E2E workflows
- [ ] Documentation updated
- [ ] All commits follow conventional commits format

## Success Criteria

âœ… **5-7 E2E test scenarios implemented**
âœ… **Complete user workflows validated**
âœ… **Headless execution confirmed**
âœ… **Fast test execution (< 30s)**
âœ… **No resource leaks**
âœ… **Clear documentation**

---

## Notes for Implementation

**Testing Philosophy:**
- Each test validates a complete user journey
- Tests are independent (no shared state)
- Use TDD: write test â†’ verify fail â†’ implement â†’ verify pass
- Commit after each task completion

**GTK Quirks:**
- Always process pending events after widget interactions
- Use wait_for_condition instead of sleep()
- Find widgets by traversing hierarchy (no direct widget references)
- Dialog signals must be emitted, not clicked

**Debugging:**
- Run with `-s` flag to see print statements
- Add `time.sleep(1)` before assertions to see UI state
- Check GTK warnings for widget lifecycle issues
- Use `pytest -vv` for detailed assertion output
